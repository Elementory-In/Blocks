{"version":3,"sources":["../../src/util/AppFileCopierHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { log } from \"builder-util\"\nimport { CONCURRENCY, FileTransformer, statOrNull, walk } from \"builder-util/out/fs\"\nimport { ensureDir, Stats } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { FileMatcher } from \"../fileMatcher\"\nimport { createElectronCompilerHost, NODE_MODULES_PATTERN } from \"../fileTransformer\"\nimport { Packager } from \"../packager\"\nimport { AppFileWalker } from \"./AppFileWalker\"\nimport { NodeModuleCopyHelper } from \"./NodeModuleCopyHelper\"\nimport { Dependency } from \"./packageDependencies\"\n\n// os path separator is used\nexport interface ResolvedFileSet {\n  src: string\n  destination: string\n\n  files: Array<string>\n  metadata: Map<string, Stats>\n  transformedFiles?: Map<number, string | Buffer> | null\n}\n\nexport async function computeFileSets(matchers: Array<FileMatcher>, transformer: FileTransformer | null, packager: Packager, isElectronCompile: boolean): Promise<Array<ResolvedFileSet>> {\n  const fileSets: Array<ResolvedFileSet> = []\n  let hoistedNodeModuleFileSets: Array<ResolvedFileSet> | null = null\n  let isHoistedNodeModuleChecked = false\n  for (const matcher of matchers) {\n    const fileWalker = new AppFileWalker(matcher, packager)\n\n    const fromStat = await statOrNull(matcher.from)\n    if (fromStat == null) {\n      log.debug({directory: matcher.from, reason: \"doesn't exist\"}, `skipped copying`)\n      continue\n    }\n\n    const files = await walk(matcher.from, fileWalker.filter, fileWalker)\n    const metadata = fileWalker.metadata\n\n    // https://github.com/electron-userland/electron-builder/issues/2205 Support for hoisted node_modules (lerna + yarn workspaces)\n    // if no node_modules in the app dir, it means that probably dependencies are hoisted\n    // check that main node_modules doesn't exist in addition to isNodeModulesHandled because isNodeModulesHandled will be false if node_modules dir is ignored by filter\n    // here isNodeModulesHandled is required only because of performance reasons (avoid stat call)\n    if (!isHoistedNodeModuleChecked && matcher.from === packager.appDir && !fileWalker.isNodeModulesHandled) {\n      isHoistedNodeModuleChecked = true\n      if ((await statOrNull(path.join(packager.appDir, \"node_modules\"))) == null) {\n        // in the prepacked mode no package.json\n        const packageJsonStat = await statOrNull(path.join(packager.appDir, \"package.json\"))\n        if (packageJsonStat != null && packageJsonStat.isFile()) {\n          hoistedNodeModuleFileSets = await copyHoistedNodeModules(packager, matcher)\n        }\n      }\n    }\n\n    const transformedFiles = new Map<number, string | Buffer>()\n    if (transformer != null) {\n      await BluebirdPromise.filter(files, (it, index) => {\n        const fileStat = metadata.get(it)\n        if (fileStat == null || !fileStat.isFile()) {\n          return false\n        }\n\n        const transformedValue = transformer(it)\n        if (transformedValue == null) {\n          return false\n        }\n\n        if (typeof transformedValue === \"object\" && \"then\" in transformedValue) {\n          return (transformedValue as Promise<any>)\n            .then(it => {\n              if (it != null) {\n                transformedFiles.set(index, it)\n              }\n              return false\n            })\n        }\n        transformedFiles.set(index, transformedValue as string | Buffer)\n        return false\n      }, CONCURRENCY)\n    }\n    fileSets.push(validateFileSet({src: matcher.from, files, metadata, transformedFiles, destination: matcher.to}))\n  }\n\n  if (isElectronCompile) {\n    // cache files should be first (better IO)\n    fileSets.unshift(await compileUsingElectronCompile(fileSets[0], packager))\n  }\n  if (hoistedNodeModuleFileSets != null) {\n    return fileSets.concat(hoistedNodeModuleFileSets)\n  }\n  return fileSets\n}\n\nfunction validateFileSet(fileSet: ResolvedFileSet): ResolvedFileSet {\n  if (fileSet.src == null || fileSet.src.length === 0) {\n    throw new Error(\"fileset src is empty\")\n  }\n  return fileSet\n}\n\nasync function copyHoistedNodeModules(packager: Packager, mainMatcher: FileMatcher): Promise<Array<ResolvedFileSet>> {\n  const productionDeps = await packager.productionDeps.value\n  const rootPathToCopier = new Map<string, Array<Dependency>>()\n  for (const dep of productionDeps) {\n    const index = dep.path.indexOf(NODE_MODULES_PATTERN)\n    if (index < 0) {\n      throw new Error(\"cannot find node_modules in the path \" + dep.path)\n    }\n\n    const root = dep.path.substring(0, index)\n    let list = rootPathToCopier.get(root)\n    if (list == null) {\n      list = []\n      rootPathToCopier.set(root, list)\n    }\n    list.push(dep)\n  }\n\n  // mapSeries instead of map because copyNodeModules is concurrent and so, no need to increase queue/pressure\n  return await BluebirdPromise.mapSeries(rootPathToCopier.keys(), async source => {\n    // use main matcher patterns, so, user can exclude some files in such hoisted node modules\n    const matcher = new FileMatcher(source, mainMatcher.to, mainMatcher.macroExpander, mainMatcher.patterns)\n    const copier = new NodeModuleCopyHelper(matcher, packager)\n    const files = await copier.collectNodeModules(rootPathToCopier.get(source)!!)\n    return validateFileSet({src: matcher.from, destination: matcher.to, files, metadata: copier.metadata})\n  })\n}\n\nconst BOWER_COMPONENTS_PATTERN = `${path.sep}bower_components${path.sep}`\n/** @internal */\nexport const ELECTRON_COMPILE_SHIM_FILENAME = \"__shim.js\"\n\nasync function compileUsingElectronCompile(mainFileSet: ResolvedFileSet, packager: Packager): Promise<ResolvedFileSet> {\n  log.info(\"compiling using electron-compile\")\n\n  const electronCompileCache = await packager.tempDirManager.getTempDir({prefix: \"electron-compile-cache\"})\n  const cacheDir = path.join(electronCompileCache, \".cache\")\n  // clear and create cache dir\n  await ensureDir(cacheDir)\n  const compilerHost = await createElectronCompilerHost(mainFileSet.src, cacheDir)\n  const nextSlashIndex = mainFileSet.src.length + 1\n  // pre-compute electron-compile to cache dir - we need to process only subdirectories, not direct files of app dir\n  await BluebirdPromise.map(mainFileSet.files, file => {\n    if (file.includes(NODE_MODULES_PATTERN) || file.includes(BOWER_COMPONENTS_PATTERN)\n      || !file.includes(path.sep, nextSlashIndex) // ignore not root files\n      || !mainFileSet.metadata.get(file)!.isFile()) {\n      return null\n    }\n    return compilerHost.compile(file)\n      .then(() => null)\n  }, CONCURRENCY)\n\n  await compilerHost.saveConfiguration()\n\n  const metadata = new Map<string, Stats>()\n  const cacheFiles = await walk(cacheDir, file => !file.startsWith(\".\"), {\n    consume: (file, fileStat) => {\n      if (fileStat.isFile()) {\n        metadata.set(file, fileStat)\n      }\n      return null\n    }\n  })\n\n  // add shim\n  const shimPath = `${mainFileSet.src}${path.sep}${ELECTRON_COMPILE_SHIM_FILENAME}`\n  mainFileSet.files.push(shimPath)\n  mainFileSet.metadata.set(shimPath, {isFile: () => true, isDirectory: () => false, isSymbolicLink: () => false} as any)\n  if (mainFileSet.transformedFiles == null) {\n    mainFileSet.transformedFiles = new Map()\n  }\n  mainFileSet.transformedFiles.set(mainFileSet.files.length - 1, `\n'use strict';\nrequire('electron-compile').init(__dirname, require('path').resolve(__dirname, '${packager.metadata.main || \"index\"}'), true);\n`)\n  return {src: electronCompileCache, files: cacheFiles, metadata, destination: mainFileSet.destination}\n}\n\n// sometimes, destination may not contain path separator in the end (path to folder), but the src does. So let's ensure paths have path separators in the end\nexport function ensureEndSlash(s: string) {\n  return s === \"\" || s.endsWith(path.sep) ? s : (s + path.sep)\n}\n"],"sourceRoot":""}
