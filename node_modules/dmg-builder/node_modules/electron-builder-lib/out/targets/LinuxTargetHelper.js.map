{"version":3,"sources":["../../src/targets/LinuxTargetHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { isEmptyOrSpaces, log } from \"builder-util\"\nimport { outputFile } from \"fs-extra-p\"\nimport { Lazy } from \"lazy-val\"\nimport * as path from \"path\"\nimport { LinuxTargetSpecificOptions } from \"..\"\nimport { LinuxPackager } from \"../linuxPackager\"\nimport { IconInfo } from \"../platformPackager\"\nimport { getTemplatePath } from \"../util/pathManager\"\n\nexport const installPrefix = \"/opt\"\n\nexport class LinuxTargetHelper {\n  private readonly iconPromise = new Lazy(() => this.computeDesktopIcons())\n\n  maxIconPath: string | null = null\n\n  constructor(private packager: LinuxPackager) {\n  }\n\n  get icons(): Promise<Array<IconInfo>> {\n    return this.iconPromise.value\n  }\n\n  // must be name without spaces and other special characters, but not product name used\n  private async computeDesktopIcons(): Promise<Array<IconInfo>> {\n    const packager = this.packager\n    const iconDir = packager.platformSpecificBuildOptions.icon\n    const sources = [iconDir == null ? \"icons\" : iconDir]\n\n    const commonConfiguration = packager.config\n    let icnsPath = (commonConfiguration.mac || {}).icon || commonConfiguration.icon\n    if (icnsPath != null) {\n      if (!icnsPath.endsWith(\".icns\")) {\n        icnsPath += \".icns\"\n      }\n      sources.push(icnsPath)\n    }\n\n    sources.push(\"icon.icns\")\n\n    sources.push(path.join(getTemplatePath(\"linux\"), \"electron-icons\"))\n\n    const result = await packager.resolveIcon(sources, \"set\")\n    this.maxIconPath = result[result.length - 1].file\n    return result\n  }\n\n  getDescription(options: LinuxTargetSpecificOptions) {\n    return options.description || this.packager.appInfo.description\n  }\n\n  async writeDesktopEntry(targetSpecificOptions: LinuxTargetSpecificOptions, exec?: string, destination?: string | null, extra?: { [key: string]: string; }): Promise<string> {\n    const data = await this.computeDesktopEntry(targetSpecificOptions, exec, extra)\n    const file = destination || await this.packager.getTempFile(`${this.packager.appInfo.productFilename}.desktop`)\n    await outputFile(file, data)\n    return file\n  }\n\n  async computeDesktopEntry(targetSpecificOptions: LinuxTargetSpecificOptions, exec?: string, extra?: { [key: string]: string; }): Promise<string> {\n    if (exec != null && exec.length === 0) {\n      throw new Error(\"Specified exec is empty\")\n    }\n\n    const appInfo = this.packager.appInfo\n\n    const productFilename = appInfo.productFilename\n\n    const desktopMeta: any = {\n      Name: appInfo.productName,\n      Comment: this.getDescription(targetSpecificOptions),\n      Exec: exec == null ? `\"${installPrefix}/${productFilename}/${this.packager.executableName}\" %U` : exec,\n      Terminal: \"false\",\n      Type: \"Application\",\n      Icon: this.packager.executableName,\n      ...extra,\n      ...targetSpecificOptions.desktop,\n    }\n\n    let category = targetSpecificOptions.category\n    if (isEmptyOrSpaces(category)) {\n      const macCategory = (this.packager.config.mac || {}).category\n      if (macCategory != null) {\n        category = macToLinuxCategory[macCategory]\n      }\n\n      if (category == null) {\n        // https://github.com/develar/onshape-desktop-shell/issues/48\n        if (macCategory != null) {\n          log.warn({macCategory}, \"cannot map macOS category to Linux. If possible mapping is known for you, please file issue to add it.\")\n        }\n        log.warn({\n          reason: \"linux.category is not set and cannot map from macOS\",\n          docs: \"https://electron.build/configuration/configuration#LinuxBuildOptions-category\",\n        }, \"application Linux category is set to default \\\"Utility\\\"\")\n        category = \"Utility\"\n      }\n    }\n    desktopMeta.Categories = `${category}${category.endsWith(\";\") ? \"\" : \";\"}`\n\n    let data = `[Desktop Entry]`\n    for (const name of Object.keys(desktopMeta)) {\n      const value = desktopMeta[name]\n      data += `\\n${name}=${value}`\n    }\n    data += \"\\n\"\n    return data\n  }\n}\n\nconst macToLinuxCategory: any = {\n  \"public.app-category.graphics-design\": \"Graphics\",\n  \"public.app-category.developer-tools\": \"Development\",\n  \"public.app-category.education\": \"Education\",\n  \"public.app-category.games\": \"Game\",\n  \"public.app-category.video\": \"Video;AudioVideo\",\n  \"public.app-category.utilities\": \"Utility\",\n  \"public.app-category.social-networking\": \"Chat\",\n  \"public.app-category.finance\": \"Finance\",\n}"],"sourceRoot":""}
