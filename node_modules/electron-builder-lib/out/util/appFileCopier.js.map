{"version":3,"sources":["../../src/util/appFileCopier.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { AsyncTaskManager } from \"builder-util\"\nimport { CONCURRENCY, FileCopier, Link, MAX_FILE_REQUESTS, FileTransformer } from \"builder-util/out/fs\"\nimport { ensureDir, readlink, Stats, symlink, writeFile } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { NODE_MODULES_PATTERN } from \"../fileTransformer\"\nimport { Packager } from \"../packager\"\nimport { ensureEndSlash, ResolvedFileSet } from \"./AppFileCopierHelper\"\n\nexport function getDestinationPath(file: string, fileSet: ResolvedFileSet) {\n  if (file === fileSet.src) {\n    return fileSet.destination\n  }\n  else {\n    const src = ensureEndSlash(fileSet.src)\n    const dest = ensureEndSlash(fileSet.destination)\n    if (file.startsWith(src)) {\n      return dest + file.substring(src.length)\n    }\n    else {\n      // hoisted node_modules\n      // not lastIndexOf, to ensure that nested module (top-level module depends on) copied to parent node_modules, not to top-level directory\n      // project https://github.com/angexis/punchcontrol/commit/cf929aba55c40d0d8901c54df7945e1d001ce022\n      const index = file.indexOf(NODE_MODULES_PATTERN)\n      if (index < 0) {\n        throw new Error(`File \"${file}\" not under the source directory \"${fileSet.src}\"`)\n      }\n      return dest + file.substring(index + 1 /* leading slash */)\n    }\n  }\n}\n\nexport async function copyAppFiles(fileSet: ResolvedFileSet, packager: Packager, transformer: FileTransformer) {\n  const metadata = fileSet.metadata\n  const transformedFiles = fileSet.transformedFiles\n  // search auto unpacked dir\n  const taskManager = new AsyncTaskManager(packager.cancellationToken)\n  const createdParentDirs = new Set<string>()\n\n  function transformContentIfNeed(sourceFile: string, index: number): Promise<any> {\n    let transformedContent: string | Buffer | Promise<string | Buffer | null> | null | undefined = transformedFiles == null ? null : transformedFiles.get(index)\n    if (transformedContent == null) {\n      transformedContent = transformer(sourceFile)\n    }\n\n    if (transformedContent != null && typeof transformedContent === \"object\" && \"then\" in transformedContent) {\n      return transformedContent as Promise<any>\n    }\n    else {\n      return Promise.resolve(transformedContent)\n    }\n  }\n\n  const fileCopier = new FileCopier()\n  const links: Array<Link> = []\n  for (let i = 0, n = fileSet.files.length; i < n; i++) {\n    const sourceFile = fileSet.files[i]\n    const stat = metadata.get(sourceFile)\n    if (stat == null) {\n      // dir\n      continue\n    }\n\n    const destinationFile = getDestinationPath(sourceFile, fileSet)\n    if (stat.isSymbolicLink()) {\n      links.push({file: destinationFile, link: await readlink(sourceFile)})\n      continue\n    }\n\n    const fileParent = path.dirname(destinationFile)\n    if (!createdParentDirs.has(fileParent)) {\n      createdParentDirs.add(fileParent)\n      await ensureDir(fileParent)\n    }\n\n    taskManager.addTask(transformContentIfNeed(sourceFile, i).then(it => copyFileOrData(fileCopier, it, sourceFile, destinationFile, stat)))\n    if (taskManager.tasks.length > MAX_FILE_REQUESTS) {\n      await taskManager.awaitTasks()\n    }\n  }\n\n  if (taskManager.tasks.length > 0) {\n    await taskManager.awaitTasks()\n  }\n  if (links.length > 0) {\n    await BluebirdPromise.map(links, it => symlink(it.link, it.file), CONCURRENCY)\n  }\n}\n\nexport function copyFileOrData(fileCopier: FileCopier, data: string | Buffer | undefined | null, source: string, destination: string, stats: Stats) {\n  if (data == null) {\n    return fileCopier.copy(source, destination, stats)\n  }\n  else {\n    return writeFile(destination, data)\n  }\n}"],"sourceRoot":""}
