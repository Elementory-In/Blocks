{"version":3,"file":"ajvErrorNormalizer.js","sourceRoot":"","sources":["../src/ajvErrorNormalizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { AdditionalPropertiesParams, ComparisonParams, DependenciesParams, ErrorObject, TypeParams } from \"ajv\"\n\nexport function normaliseErrorMessages(errors: Array<ErrorObject>, schemeData: object) {\n  const printer = new SchemeErrorPrinter(schemeData)\n  return \"Configuration is invalid.\\n\" +\n    filterErrors(errors)\n      .map(it => \" - \" + indent(printer.formatValidationError(it), \"   \", false))\n      .join(\"\\n\")\n}\n\n//tslint:disable-next-line:no-empty-interface\ninterface Scheme {\n  // to ensure that proper arg is passed\n}\n\nclass SchemeErrorPrinter {\n  constructor(readonly schemeData: Scheme) {\n  }\n\n  formatValidationError(error: ErrorObject) {\n    const dataPath = `configuration${error.dataPath}`\n    if (error.keyword === \"additionalProperties\") {\n      return `${dataPath} has an unknown property '${(error.params as AdditionalPropertiesParams).additionalProperty}'. These properties are valid:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"oneOf\" || error.keyword === \"anyOf\") {\n      const children = (error as any).children\n      if (children && children.length > 0) {\n        // use set to remove duplicated messages like \"should be an object.\"\n        return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}\\n` +\n          `Details:\\n${Array.from(new Set(children.map((it: ErrorObject) => \" * \" + indent(this.formatValidationError(it), \"   \", false)))).join(\"\\n\")}`\n      }\n      return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}`\n\n    }\n    else if (error.keyword === \"enum\") {\n      if (error.parentSchema && (error.parentSchema as any).enum && (error.parentSchema as any).enum.length === 1) {\n        return `${dataPath} should be ${this.getSchemaPartText(error.parentSchema)}`\n      }\n      return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"allOf\") {\n      return `${dataPath} should be:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"type\") {\n      switch ((error.params as TypeParams).type) {\n        case \"object\":\n          return `${dataPath} should be an object.`\n        case \"string\":\n          return `${dataPath} should be a string.`\n        case \"boolean\":\n          return `${dataPath} should be a boolean.`\n        case \"number\":\n          return `${dataPath} should be a number.`\n        case \"array\":\n          return `${dataPath} should be an array:\\n${this.getSchemaPartText(error.parentSchema)}`\n      }\n      return `${dataPath} should be ${(error.params as TypeParams).type}:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"instanceof\") {\n      return `${dataPath} should be an instance of ${this.getSchemaPartText(error.parentSchema)}.`\n    }\n    else if (error.keyword === \"required\") {\n      const missingProperty = (error.params as DependenciesParams).missingProperty.replace(/^\\./, \"\")\n      return `${dataPath} misses the property '${missingProperty}'.\\n${this.getSchemaPartText(error.parentSchema, [\"properties\", missingProperty])}`\n    }\n    else if (error.keyword === \"minLength\" || error.keyword === \"minItems\") {\n      if ((error.params as ComparisonParams).limit === 1) {\n        return `${dataPath} should not be empty.`\n      }\n      else {\n        return `${dataPath} ${error.message}`\n      }\n    }\n    else if (error.keyword === \"absolutePath\") {\n      const baseMessage = `${dataPath}: ${error.message}`\n      if (dataPath === \"configuration.output.filename\") {\n        return `${baseMessage}\\n` +\n          \"Please use output.path to specify absolute path and output.filename for the file name.\"\n      }\n      return baseMessage\n    }\n    else {\n      // eslint-disable-line no-fallthrough\n      return `${dataPath} ${error.message} (${JSON.stringify(error, null, 2)}).\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n  }\n\n  private getSchemaPart(path: string) {\n    const pathList = path.split(\"/\").slice(0, path.length)\n    let schemaPart = this.schemeData as any\n    for (let i = 1; i < pathList.length; i++) {\n      const inner = schemaPart[pathList[i]]\n      if (inner) {\n        schemaPart = inner\n      }\n    }\n    return schemaPart\n  }\n\n  private getSchemaPartText(schemaPart: any, additionalPath: Array<string> | null = null) {\n    if (additionalPath != null) {\n      for (const p of additionalPath) {\n        const inner = schemaPart[p]\n        if (inner) {\n          schemaPart = inner\n        }\n      }\n    }\n\n    while (schemaPart.$ref != null) {\n      schemaPart = this.getSchemaPart(schemaPart.$ref)\n    }\n\n    let schemaText = this.formatSchema(schemaPart)\n    let description = schemaPart.description\n    if (description != null) {\n      description = description.trim()\n      const twoLineBreakPosition = description.indexOf(\"\\n\\n\")\n      description = twoLineBreakPosition < 0 ? description : description.substring(0, twoLineBreakPosition)\n      schemaText += `\\n${description}\\n`\n    }\n    return schemaText\n  }\n\n  private formatSchema(schema: any, prevSchemas?: any) {\n    prevSchemas = prevSchemas || []\n\n    const formatInnerSchema = (innerSchema: any, isAddSelf = false): string => {\n      if (!isAddSelf) {\n        return this.formatSchema(innerSchema, prevSchemas)\n      }\n      if (prevSchemas.indexOf(innerSchema) >= 0) {\n        return \"(recursive)\"\n      }\n      return this.formatSchema(innerSchema, prevSchemas.concat(schema))\n    }\n\n    if (schema.type === \"string\") {\n      if (schema.minLength === 1) {\n        return \"non-empty string\"\n      }\n      else if (schema.minLength > 1) {\n        return `string (min length ${schema.minLength})`\n      }\n      else {\n        return \"string\"\n      }\n    }\n    else if (schema.type === \"boolean\") {\n      return \"boolean\"\n    }\n    else if (schema.type === \"number\") {\n      return \"number\"\n    }\n    else if (schema.type === \"object\") {\n      if (schema.properties) {\n        const required = schema.required || []\n        return `object { ${Object.keys(schema.properties).map(property => {\n          if (required.indexOf(property) < 0) {\n            return property + \"?\"\n          }\n          return property\n        }).concat(schema.additionalProperties ? [\"...\"] : []).join(\", \")} }`\n      }\n      if (schema.additionalProperties) {\n        return `object { <key>: ${formatInnerSchema(schema.additionalProperties)} }`\n      }\n      return \"object\"\n    }\n    else if (schema.type === \"array\") {\n      return `[${formatInnerSchema(schema.items)}]`\n    }\n\n    switch (schema.instanceof) {\n      case \"Function\":\n        return \"function\"\n      case \"RegExp\":\n        return \"RegExp\"\n    }\n\n    if (schema.$ref != null) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true)\n    }\n    if (schema.allOf) {\n      return schema.allOf.map(formatInnerSchema).join(\" & \")\n    }\n    if (schema.oneOf) {\n      return schema.oneOf.map(formatInnerSchema).join(\" | \")\n    }\n    if (schema.anyOf) {\n      return schema.anyOf.map(formatInnerSchema).join(\" | \")\n    }\n    if (schema.enum) {\n      return schema.enum.map((it: object) => JSON.stringify(it)).join(\" | \")\n    }\n    return JSON.stringify(schema, null, 2)\n  }\n}\n\nfunction indent(str: string, prefix: string, isFirstLine: boolean) {\n  if (isFirstLine) {\n    return prefix + str.replace(/\\n(?!$)/g, \"\\n\" + prefix)\n  }\n  else {\n    return str.replace(/\\n(?!$)/g, `\\n${prefix}`)\n  }\n}\n\nfunction filterErrors(errors: Array<ErrorObject>) {\n  let newErrors: Array<any> = []\n  for (const error of errors) {\n    const dataPath = error.dataPath\n    let children: Array<ErrorObject> = []\n    newErrors = newErrors.filter(oldError => {\n      if (!oldError.dataPath.includes(dataPath)) {\n        return true\n      }\n\n      if (oldError.children != null) {\n        children = children.concat(oldError.children.slice(0))\n      }\n      oldError.children = null\n      children.push(oldError)\n      return false\n    })\n\n    if (children.length > 0) {\n      (error as any).children = children\n    }\n    newErrors.push(error)\n  }\n  return newErrors\n}"]}
